<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>바스크립트에서 중요한 배열과 객체</title>
</head>
<style>
    .area{width:500px;border:1px solid lightcoral;}
    .big{height:500px;}
    .small{height:300px;}
    button{border:none; background-color: rgb(194, 232, 247); border-radius: 5px; width:150px; padding:10px; color:#333; font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.2s;}
    button:hover{background-color: rgb(149, 196, 214);}
</style>
<body>
    <p>
        여러 개의 값을 담기 위해 사용하는 자료형 <br>
        자바스크립트에서는 변수 선언 시 별도의 타입을 지정하지 않기 때문에 <br>
        배열도 const로 선언함!
    </p>
    <button id="btn1">버튼</button>
    <div id="area1" class="area small"></div>

    <script>
        document.querySelector('#btn1').onclick = () => {

            // 배열의 선언 및 초기화
            const array = ['홍길동', 15, true, [1, 2]]; // 자바 : == Object[] array = new Object[10];
            console.log(array);

            console.log(array[1]);  // 15
            console.log(array[3][1]); // 2

            const area = document.getElementById('area1');
            // 슬슬 자바처럼 가보자
            // area.innerHTML = `${array[0]} <br>`;
            // area.innerHTML += `${array[1]} <br>`;
            // area.innerHTML += `${array[2]} <br>`;
            // area.innerHTML += `${array[3]} <br>`;


            // 반복문 for문
            /*
            for(let i = 0; i < array.length; i++){
                area.innerHTML +=  `${array[i]} <br>`;
            }
           */

            // for in문
            // for(let i in 순차적으로 요소에 접근할 배열)
            /*
            for(let i in array){
                console.log(i); // index
                area.innerHTML+=  `${array[i]} <br>`;
            }
            */

            // ★★★★★ for of문 ★★★★★
            /*
            for(let value of array) {
                //console.log(value); // 배열의 요소
                area.innerHTML += `${[value]} <br>`;
            }
            */

            console.log('-------------------이게 맵이다!!-----------------------');
            // 고급 함수
            /*
            const str = array.map((e) => { // 요소 하나하나접근
                console.log(e);
                return `${e} <br>`; // 배열 반환
            }).join(""); // 배열의 요소들 갖다가 문자열로 하나로 합쳐주는 메소드이다.
            // console.log(`map으로 반환받은 배열 : ${str}`);
            area.innerHTML = str;
            // 중요 : 익명함수이니  array.map(function(e) { ==> array.map((e) => {  가능하며
            //          중괄호랑  return `${e} <br>`; 을 싹 날릴 수 있다.
            */
            area.innerHTML = array.map((e) => `${e}<br>`).join("");


            // 일반적으로 순수 자바스크립트를 사용하는 회사일 경우 : for of 문 사용
            // 리액트 사용하는 회사일 경우 : 고급 함수 사용 => why? side effect 줄이기 위함( 부작용 ↓ )
        
            /*
                익명함수 선언?

                function () {
                
                }

                =============>

                () => {
                
                }
                ---------------------------------------------
                *매개변수 익명함수 ?

                function(a){
                
                }
                
                =============>

                a => {

                }

                ---------------------------------------------
                *매개변수 2개 이상익명함수 ?

                function(a, b){
                
                }

                =============>

                (a, b) => {
                
                }

                ---------------------------------------------
                return 하나인 익명함수
                function() {
                    return a;
                }

                =============>

                () => a
            
            */
        
        }
    </script>

    <h3>* 배열의 선언</h3>

    <p>
        빈 배열을 선언 할 때, 크기를 지정할 수 있음<br>
    </p>

    <button onclick="defArray();">버튼이다</button>
    <div id="area2" class="area small"></div>

    <script>
        function defArray(){
            const array1 = [];// 기본적으로 배열 리터럴 대입해서 배열 선언하는 방법 : 권장 사항이다.
            const array2 = new Array(3);
            console.log(array1); // []
            console.log(array2); // [empty × 3] // 요소는 존재하지 않는데 배열 크기가 3 이니 값을 돌릴 때 문제가 발생 할 수 있으니 조심 // 옛날에 사용한게 있으니 알고만 있고 쓰지 말자

            // 배열에 요소 추가
            array1[0] = '사과';
            array1[1] = '바나나';
            array1[2] = '당근';
            document.querySelector('#area2').innerHTML = array1; // 배열 요소에 추가 // 사과,바나나,당근


            const array3 = ['사과', '바나나', '당근'];
            const area2 = document.querySelector("#area2");
            for(let v of array3){
                area2.innerHTML += `${v}`;
            }

        }
    </script>

    <hr>

    <h3>* 배열용 메소드</h3>
    <h4>1) indexOf(찾고자하는 요소) : 배열에서 해당 요소가 위치한 인덱스 반환</h4>

    <button onclick="holiday();">빨간날찾기</button>
    <div id="area3" class="area small"></div>

    <script>
        function holiday(){

            const days = [
                '추석',
                '개천절',
                '설날',
                '크리스마스',
                '부처님오신날',
                '현충일',
                '광복절',
                '어린이날',
                '삼일절',
                '한글날',
            ];
            console.log(days.indexOf('추석'));      // 0
            console.log(days.indexOf('현ㄴ충일'));  // -1


            // 빨간날 찾기 버튼을 클릭하면
            // 사용자에게 텍스트를 입력 받아서(window.prompt());

            // 사용자가 입력한 텍스트가 배열의 요소로 존재할 경우
            // id가 area3인 div요소인 content영역에
            // xxx(사용자가 입력한 텍스트)은(는) 빨간날이 맞습니다.

            // 사용자가 입력한 텍스트가 배열의 요소로 존재하지 않은 경우
            // id가 area3인 div요소의 content영역에
            // xxx(사용자가 입력한 텍스트)은(는) 빨간날이 아닙니다.

            // 라고 출력해주세요
            const day = prompt("무슨 빨간날을 찾으시나요?");
            // const area = document.getElementById('area3');
            // 요소 존재 == index(0이상의 정수)
            // 요소 존재하지 않는다 == -1
            /*
            if(!days.indexOf(day)){
                area.innerHTML = `${day}은(는) 빨간날이 맞습니다.`
            } else{
                area.innerHTML = `${day}은(는) 빨간날이 아닙니다.`
            }
            */
            // 방법3.
            const index = days.indexOf(day);
            const result = index != -1 ? '맞습니다' : '아닙니다';
            document.getElementById('area3').innerHTML = `${day}는 빨간날이 ${result}`;


            // 방법 1
            // for(let valud of days) {
            //    if(day == value){
            // }
            // }
        
            // 방법 2
            // console.log(days.includes(day));

        }
    </script>

    <hr>

    <h3>참고사항</h3>
    <button onclick="remember();">알아두자</button>

    <script>
        function remember(){
            // 자바스크립트에서 동등비교
            console.log(1 == 1) // true
            console.log('1' == 1); //true
            console.log([] == 0); // 이게 대체 왜? (값만 비교)

            console.log('1' === 1); // false : 값, 자료형 둘다 일치해야만 true ( 값과 타입 둘다 비교 )

            // 구조분해할당
            const array = ['Apple', 'Banana', 'Carrot'];

            //console.log(array); // (3) ['Apple', 'Banana', 'Carrot']

            /*
            const el1 = array[0];
            const el2 = array[1];
            const el3 = array[2];
            console.log(el1, el2, el3);

            //Apple Banana Carrot
            */

            
            const str = [...array];
            console.log(str);
            //(3) ['Apple', 'Banana', 'Carrot']


            // 한번에 변수에 담기
            const [el1, el2, el3] = array;
            console.log(el1, el2, el3);
            //Apple Banana Carrot
        }
    </script>

    <hr>

    <h4>2) concat(배열, 배열, 배열) : 여러 개의 배열을 합칠 때 사용</h4>
    <button onclick="merge();">확인</button>
    <div id="area4" class="area big"></div>

    <script>
        function merge(){

            const array1 = ['가나다', '라마바'];
            const array2 = ['사아자', '차카파'];

            
            const area = document.querySelector('#area4');

            // 예시1)
            area.innerHTML = `${array1} <br>
                                ${array1.concat(array2)} <br>
                                ${array1} <br>`; // 원본 배열 수정이 아닌 두개의 배열 요소를 반환
                                // 가나다,라마바 / 가나다,라마바,사아자,차카파 / 가나다 라마바


            // 예시2)
            const array3 = array1.concat(array2);
            area.innerHTML = `${array3}`; // 가나다,라마바,사아자,차카파

            // 예시3)
            const array4 = [...array1, ...array2];
            area.innerHTML = `${array4}`; // 배열의 요소를 풀어서 반환 //가나다,라마바,사아자,차카파

            
        }
    </script>

    <hr>

    <h4>3) reverse() : 배열의 요소 순번을 역순으로 바꿔줌</h4>

    <button onclick="arrayReverse();">리버스</button>
    <div id="area5" class="area small"></div>

    <script>
        function arrayReverse(){
            const array = ['Apple', 'Banana', 'Melon', 'kiwi'];
            // const newArray = array ; // 얕은복사
            // const newArray = [...array]; // 깊은 복사 : 완전히 새 배열을 복사하여 관리 [보편적으로 많이 사용]
            const area5 = document.getElementById('area5');

            area5.innerHTML = `${array} <br>`; //Apple,Banana,Melon,kiwi
            array.reverse();
            area5.innerHTML = `${array} <br>`; //kiwi,Melon,Banana,Apple
        }
    </script>

    <hr>
    <h4>4) sort() : 배열의 요소를 정렬해줌</h4>
    <button onclick="sort();">정렬하자</button>
    <div id="area6" class="area small"></div>

    <script>
        function sort(){

            const array = ['Banana', 'Lemon', 'Apple', 'Kiwi', 'Mango', 'WaterMelon', 'イチジク', '딸기'];
            
            const area6 = document.getElementById('area6');
            area6.innerHTML = `${array} <br>`;
            array.sort();  // 오름차순 정렬 : 정렬 시 속도가 좀 더 빠름 (단, 여기보다 데이터 자체 SELECT ~ ORDER BY에서 처리하는게 성능이 더 좋다.)
            //Apple,Banana,Kiwi,Lemon,Mango,WaterMelon,イチジク,딸기
            array.sort().reverse();  // 내림차순 정렬
            //딸기,イチジク,WaterMelon,Mango,Lemon,Kiwi,Banana,Apple
            area6.innerHTML = `${array} <br>`;
        }
    </script>
    <hr>
    <h4>
        5_1) push(추가할요소) : 배열 가장 마지막에 인자로 전달된 요소를 추가하고 크기를 반환<br>
        5_2) pop() : 배열의 가장 마지막 요소를 뽑아내고 뽑은 요소를 반환
    </h4>

    <button id="btn7">요소추가</button>
    <div id="area7" class="area big"></div>

    <script>
        const btn = document.querySelector('#btn7');

        btn.addEventListener('click', () => {
            
            const area = document.getElementById('area7');
            const lunchMenu = ['샐러드', '짜장면', '김치찌개', '돈까스'];

            //area.innerHTML = `${lunchMenu}<br>`;
            const newMenu = prompt('추가할 메뉴를 입력해줘!!!!!!!');

            console.log(newMenu);
            lunchMenu.push(newMenu);
            area.innerHTML += `push(요소가 추가된 점심메뉴) : ${lunchMenu} <br>`;

            // 랜덤 뽑기
            const num = parseInt(Math.random() * lunchMenu.length);
            alert(`오늘의 점심 메뉴는 ${lunchMenu[num]} 당첨~`);

            // pop한 요소 반환 : 제일 마지막 요소가 반환됨
            area.innerHTML += `pop(마지막요소반환) : ${lunchMenu.pop()} <br>`;

            // 6_1) shift() : 0번인덱스 요소 뽑아내기
            // 6_2) unshift(추가할요소) : 0번인덱스에 요소 추가
            const salad = lunchMenu.shift();
            area.innerHTML += `shift(0번인덱스요소뽑기) :  ${salad} <br>`;
            lunchMenu.unshift(newMenu);
            area.innerHTML += `unshift(0번인덱스에요소추가) : ${lunchMenu}<br>`;
            
            // 새로운 배열
            const newLunchMenu = [...lunchMenu, '제육볶음'];
            area.innerHTML += `[...lunchMenu, '제육볶음'] : ${newLunchMenu}<br>`;

            /*
            3 입력,
            push(요소가 추가된 점심메뉴) : 샐러드,짜장면,김치찌개,돈까스,3
            pop(마지막요소반환) : 3
            shift(0번인덱스요소뽑기) : 샐러드
            unshift(0번인덱스에요소추가) : 3,짜장면,김치찌개,돈까스
            [...lunchMenu, '제육볶음'] : 3,짜장면,김치찌개,돈까스,제육볶음
            */

        });
        
    </script>

    <hr>
    <h4>
        7_1) slice(begin, end) : 배열의 요소를 추출해줌<br>
        7_2) slice(begin, coun, el) : 배열의 요소를 추출해서 제거 및 추가
    </h4>
    <button onclick="goal();">추추출하자자</button>
    <div id="area8" class="area big"></div>

    <script>
        function goal(){
            const area = document.getElementById('area8');
            const array = ['나는', '올 해', '다이어트', '하겠다']; //join , 제거

            area.innerHTML = `올해 목표 : ${array} <br>`;

            // slice
            area.innerHTML += `slice(특정위치요소추출) : ${array.slice(2, 4)} <br>`;

            // splice
            area.innerHTML += `splice(특정위치요소삭제) : ${array.splice(1, 1)} <br>`;
            area.innerHTML += `splice(특정위치요소삭제) 배열 결과 : ${array} <br>`;
            area.innerHTML += `splice(특정위치요소추가) :${array.splice(1, 0, '내년에')} <br>`;
            area.innerHTML += array;

            /*
            올해 목표 : 나는,올 해,다이어트,하겠다
            slice(특정위치요소추출 2, 4) ) : 다이어트,하겠다
            splice(특정위치요소삭제 1, 1) : 올 해
            splice(특정위치요소삭제) 배열 결과 array : 나는,다이어트,하겠다
            splice(특정위치요소추가 1, 0, '내년에') :
            나는,내년에,다이어트,하겠다
            */
        }
    </script>

    <hr>
    <h4>
        8) join(구분자) : 배열에 담긴 요소들을 하나의 string 타입 문자열로 합쳐주는 메소드
    </h4>
    <button onclick="join();">버튼</button>
    <div id="area9" class="area small"></div>

    <script>
        function join(){
            const area = document.querySelector('#area9');
            const arr = ['A', 'P', 'P', 'L', 'E']; // 스타일 1 : 보통 일렬로 사용하는 경우는 마지막에 , 사용하지 않는다.
            const arr1 = ['A',
                            'P',
                            'P',
                            'L',
                            'E',
                        ]; // 스타일 2 : 예) github에 올릴 경우 변동 사항 체크 시 확인이 어렵기 때문에 마지막에 , 를 추가해준다.

            //console.log(arr);
            // 배열
            area.innerHTML = `${arr} <br>`; // A,P,P,L,E
            area.innerHTML +=`${arr.join()} <br>`; // A,P,P,L,E
            area.innerHTML +=`${arr.join('')} <br>`;// APPLE
            // join메소드는 , 를 가지고 문자열로 합쳐주기 떄문에
            // 구분자를 지정해줄 수 있음.


            // 객체 배열 {Key : Value}
            const obj = {
                과일 : 'APPLE',
            }
            console.log(obj); // {과일: 'APPLE'}
            area.innerHTML += `${obj} <br>`; // [object(자료형==객체타입) Object(프로토타입)]
            // 배열과 객체 배열이 다른 이유는?
            // 배열을 HTML 요소에 출력할 경우
            // div.innerHTML = arr
            // 자바 : println(참조자료형변수.toString()); : 참조자료형변수 ==> toString() 메소드 결과가 나옴
            area.innerHTML += arr.toString(); // 자바 동일하게 toString이 찍힘.  A,P,P,L,E
        }
    </script>
</body>
</html>